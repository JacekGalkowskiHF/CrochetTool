1. sitch creationas 
2. rewrite bubbling rules + validate object lifecycle (node, link, stitch)

GENERAL CREATION RULE:

if A calls a constructor of B, where B is structural element of A, the sequence is:
1. A calls "new B( A )"
2. within the B constructor:
	a. B is all set up
	b. A is registered as the containing context (using B's "this.registerContext()")
	c. B is returned
3. if call to new B() was successful, B is registered back in A as an element (using A's "registerB()")

CREATION SPECIAL CASE:
creation of a Link

Link constructor calls "node.regisnterLink( self )" for each C of the linked nodes

GENERAL REMOVAL RULES:

whenever A is removed, it first calls B.remove() on all it's direct sub elements
then it calls "deregister( self )" self on remaining elements (sub- and sup-) it has references to

REMOVAL SPECIAL CASE:
- a Node has executed "deregisterLink" and is left with no links => it calls remove() on itself
- a node was requested to call its "remove()" => it first calls "remove()" on all is links
- a link has executed "deregisterNode" => it calls remove() on itself instead


THEREFORE each class X should enable following interfaces:
X.registerContext( superElementClass )
X.deregisterContext( superElementClass )
X.registerSublEmentClass( subElementClass ) where "subElementClass" can be any of the allowed sub-elements of X (all levels)
X.deregisterSublEmentClass( subElementClass ) 
X.remove()
